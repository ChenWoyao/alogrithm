# 关于树结构的基本知识
```
树中节点数 = 总分叉数 + 1
叶子节点的度数为0, 度就是指该节点的直接子节点有几个
树的存储结构：{
    双亲表示法：
    孩子表示法：
    孩子兄弟表示法:
}
完全二叉树：从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。

二叉树第i层最多有2^(i-1)个节点
二叉树深度为k最多有2^k-1个节点
二叉树的终端结点数为n1，度数为2的结点数为n2, 则n1 = n2 + 1
完全二叉树的结点数为n,则深度为lg2(n)+1
```

# 二叉树相关的题目
# 二叉搜索树相关的题目
## 性质
若它的左子树不为空，则左子树上所有节点的值均小于它的根结构的值
若它的右子树不为空，则右子树上所有节点的值均大于它的根结构的值
它左，右子树也分别是二叉排序树

二叉搜索树的中序遍历是一个有序数组
# 平衡二叉树(AVL)相关的题目
## 性质
是一种二叉搜索树，其中每一个节点的左子树和右子树的高度差至多等于1
也就是说二叉树上所有节点的平衡因子(BF:节点的左子树深度减去节点右子树深度)只可能是-1，0，1.

## AVL的结构代码
```
    class BitNode {
        construct(data, lchild, rchild) {
            this.bf = 0 // 节点的平衡因子
            this.data = data
            this.lchild = (lchild === undefined ? lchild : null)
            this.rightchild = (rchild === undefined ? rchild : null)
        }
        // 对以p为根的二叉排序树右旋操作，1. 平衡因子大于1需要右旋， 2. 使得平衡因子变成负数
        R_Rotate(p) {
            // p的左节点
            const l = p.lchild
            // 将原来p左节点的右子树变成p的左子树
            p.lchild = l.rchild
            // 旋转后原来p的左节点的右节点变成p
            l.rchild = p
            // p指向新的节点
            p = l
        }
        // 左旋操作
        L_Rotate(p) {
            const r = p.rchild
            p.rchild = r.lchild
            r.lchild = p
            p = r
        }
    }
```
## 将一颗二叉搜索树变成AVL的过程
![avl1](http://121.5.231.10:3000/alogrithm/avl/avl1.png)
![avl1](http://121.5.231.10:3000/alogrithm/avl/avl2.png)
![avl1](http://121.5.231.10:3000/alogrithm/avl/avl3.png)
![avl1](http://121.5.231.10:3000/alogrithm/avl/avl4.png)
# 待刷的题目
## 四数之和
## 连续子数组的最大和
## 扑克牌顺子
## 顺时针打印矩阵
## 数组中的逆序对
## 数据流中的中位数
## 最小的k个数
## 和为S的连续正整数序列
